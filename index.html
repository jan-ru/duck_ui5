<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DuckDB-WASM Viewer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>DuckDB-WASM Viewer</h1>
  <input type="file" id="file" accept=".db">
  <div>
    <select id="codeFilter" disabled>
      <option value="">Select Code...</option>
    </select>
    <select id="periodeFilter" disabled>
      <option value="">Select Periode...</option>
    </select>
    <select id="code1Filter" disabled>
      <option value="">Select Code1...</option>
    </select>
    <button id="showAll" disabled>Show All</button>
    <button id="rollupAccounts" disabled>Rollup Accounts</button>
  </div>
  <div id="loading" style="display: none;">Loading...</div>
  <div id="error" style="display: none; color: red;"></div>
  <div id="out"></div>

  <script type="module">
    import * as duckdb from "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm/+esm";

    // DOM elements
    const input = document.getElementById("file");
    const out = document.getElementById("out");
    const loading = document.getElementById("loading");
    const errorDiv = document.getElementById("error");
    const codeFilter = document.getElementById("codeFilter");
    const periodeFilter = document.getElementById("periodeFilter");
    const code1Filter = document.getElementById("code1Filter");
    const showAllBtn = document.getElementById("showAll");
    const rollupAccountsBtn = document.getElementById("rollupAccounts");

    // Constants
    const DB_FILE = 'data.db';
    const TABLE_NAME = 'uploaded_db.transactions';

    let conn = null;

    // Show/hide loading indicator
    function setLoading(isLoading) {
      loading.style.display = isLoading ? 'block' : 'none';
      out.style.display = isLoading ? 'none' : 'block';
    }

    // Show error message
    function showError(message) {
      errorDiv.textContent = `Error: ${message}`;
      errorDiv.style.display = 'block';
      setTimeout(() => errorDiv.style.display = 'none', 5000);
    }

    // Escape single quotes for SQL
    function escapeSql(value) {
      return value.replace(/'/g, "''");
    }

    // Format timestamp to dd/mm/yyyy
    function formatDate(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    }

    // Format number with thousands separator and 2 decimals
    function formatNumber(num) {
      if (num === null || num === undefined || num === '') return '';
      return Number(num).toLocaleString('nl-NL', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
    }

    // Format cell value based on column name
    function formatCell(header, value) {
      if (header === 'Boekdatum') {
        return formatDate(value);
      } else if (header === 'Saldo') {
        return formatNumber(value);
      }
      return value;
    }

    // Populate dropdown with unique values
    async function populateDropdown(dropdown, columnName, defaultText) {
      try {
        const query = `SELECT DISTINCT ${columnName} FROM ${TABLE_NAME} ORDER BY ${columnName}`;
        const result = await conn.query(query);
        const rows = result.toArray();

        dropdown.innerHTML = `<option value="">${defaultText}</option>`;
        rows.forEach(row => {
          const option = document.createElement('option');
          option.value = row[columnName];
          option.textContent = row[columnName];
          dropdown.appendChild(option);
        });
      } catch (error) {
        showError(`Failed to populate ${columnName}: ${error.message}`);
      }
    }

    // Convert array of objects to HTML table
    function renderTable(rows) {
      if (!rows.length) return "<p>No data</p>";
      const headers = Object.keys(rows[0]);
      return `
        <table>
          <thead>
            <tr>${headers.map(h => `<th>${h}</th>`).join("")}</tr>
          </thead>
          <tbody>
            ${rows.map(r => `<tr>${headers.map(h => {
              const value = formatCell(h, r[h]);
              const align = h === 'Saldo' ? ' style="text-align: right;"' : '';
              return `<td${align}>${value}</td>`;
            }).join("")}</tr>`).join("")}
          </tbody>
        </table>
      `;
    }

    async function loadAndDisplayData(query) {
      try {
        setLoading(true);
        const result = await conn.query(query);
        const rows = result.toArray();
        out.innerHTML = renderTable(rows);
      } catch (error) {
        showError(`Failed to load data: ${error.message}`);
      } finally {
        setLoading(false);
      }
    }

    input.onchange = async () => {
      const file = input.files[0];
      if (!file) return;

      try {
        setLoading(true);

        // Load DuckDB-WASM bundle
        const bundles = duckdb.getJsDelivrBundles();
        const bundle = await duckdb.selectBundle(bundles);
        const worker = new Worker(URL.createObjectURL(
          new Blob([`importScripts("${bundle.mainWorker}")`])
        ));

        const db = new duckdb.AsyncDuckDB(new duckdb.ConsoleLogger(), worker);
        await db.instantiate(bundle.mainModule);
        conn = await db.connect();

        // Register the uploaded DuckDB file
        await db.registerFileHandle(
          DB_FILE,
          file,
          duckdb.DuckDBDataProtocol.BROWSER_FILEREADER
        );

        // Attach the database
        await conn.query(`ATTACH '${DB_FILE}' AS uploaded_db`);

        // Query and display all data
        await loadAndDisplayData(`SELECT * FROM ${TABLE_NAME}`);

        // Populate all dropdowns using the helper function
        await Promise.all([
          populateDropdown(codeFilter, 'Code', 'Select Code...'),
          populateDropdown(periodeFilter, 'Periode', 'Select Periode...'),
          populateDropdown(code1Filter, 'Code1', 'Select Code1...')
        ]);

        // Enable filters
        codeFilter.disabled = false;
        periodeFilter.disabled = false;
        code1Filter.disabled = false;
        showAllBtn.disabled = false;
        rollupAccountsBtn.disabled = false;
      } catch (error) {
        showError(`Failed to load file: ${error.message}`);
      } finally {
        setLoading(false);
      }
    };

    // Build WHERE clause based on active filters with SQL escaping
    function buildWhereClause() {
      const conditions = [];
      if (codeFilter.value) {
        conditions.push(`Code = '${escapeSql(codeFilter.value)}'`);
      }
      if (periodeFilter.value) {
        conditions.push(`Periode = '${escapeSql(periodeFilter.value)}'`);
      }
      if (code1Filter.value) {
        conditions.push(`Code1 = '${escapeSql(code1Filter.value)}'`);
      }
      return conditions.length > 0 ? ` WHERE ${conditions.join(' AND ')}` : '';
    }

    // Apply filters and reload data
    async function applyFilters() {
      const whereClause = buildWhereClause();
      await loadAndDisplayData(`SELECT * FROM ${TABLE_NAME}${whereClause}`);
    }

    // Perform rollup on accounts
    async function rollupAccounts() {
      const whereClause = buildWhereClause();
      const query = `
        SELECT
          CodeGrootboekrekening,
          NaamGrootboekrekening,
          SUM(Saldo) as Saldo
        FROM ${TABLE_NAME}${whereClause}
        GROUP BY CodeGrootboekrekening, NaamGrootboekrekening
        ORDER BY CodeGrootboekrekening
      `;
      await loadAndDisplayData(query);
    }

    // Event handlers for filters
    codeFilter.onchange = applyFilters;
    periodeFilter.onchange = applyFilters;
    code1Filter.onchange = applyFilters;

    showAllBtn.onclick = async () => {
      codeFilter.value = "";
      periodeFilter.value = "";
      code1Filter.value = "";
      await loadAndDisplayData(`SELECT * FROM ${TABLE_NAME}`);
    };

    rollupAccountsBtn.onclick = rollupAccounts;
  </script>
</body>
</html>
